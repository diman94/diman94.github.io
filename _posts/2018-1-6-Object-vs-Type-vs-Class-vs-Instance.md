---
layout: post
title: Object vs Type vs Class vs Instance
---

Описание связи между объектом, типом, классом и экземпляром в Python.

## Объекты:

Объекты - способ представления любых сущностей в Python. Все данные в Python представлены объектами и связями объектов. 
У каждого объекта есть идентификатор, тип и значение. Идентификатор (identity) никогда не меняется с момента создания объекта. 
Оператор `is` сравнивает идентификтаторы двух объектов; функция `id()` возвращает целочисленный идентификатор объекта.

*Для CPython, id(x) - адрес памяти, где хранится x.*

```python
>>> a = 127
>>> b = 128
>>> id(a)
1465020576
>>> id(b)
1465020608
>>> a is b
False
```

В Python все - объект. Списки - это объекты. Строки, модули, функции - это объекты. Байткод программы хранится как объект. У всех объектов есть типы и идентификаторы:

```python
>>> def dummy(): pass
...
>>> type(dummy), id(dummy)
(<class 'function'>, 2122090425880)
>>> type(dummy.__code__), id(dummy.__code__)
(<class 'code'>, 2122094942368)
>>>
```

Модель "все - объект" прослеживается и в самой реализации CPython. В коде CPyton к любой сущности, упомянутой выше, можно обратиться через указатель на стркутуру PyObject.

## Типы:
У каждого объекта Python есть тип. Тип можно выяснить, вызвав "встроенную функцию" `type()`. Тип - это тоже объект, поэтому у него есть собственный тип, который называется `type`. Этот факт не слишком полезен для написания простого кода на Python, однако, он важен для понимания внутренностей CPython:

```python
>>> type(42)
<class 'int'>
>>> type(type(42))
<class 'type'>
>>> type(type(type(42)))
<class 'type'>
```
Все типы сходятся к type.

## Классы
Давным-давно была разница между встроенными классами и пользовательскими классами, но с версии 2.2 (классы "нового стиля", унаследованные от object в 2.x, и все классы в 3.x) значимых отличий нет. В сущности, класс это механизм Python, который позволяет создавать пользовательские типы в коде Python.
```python
>>> class Snake: pass
...
>>> s = Snake()
>>> type(s)
<class '__main__.Snake'>
>>>
```
Используя этот механизм, мы создали Snake - пользовательский тип. s - экземпляр класса Snake. Другими словами, это объект и его тип - Snake.

Как любой другой тип, Snake это тоже объект, и у него тоже есть тип. Его тип - type.

```python
>>> type(type(s))
<class 'type'>
```

Термины "class" и "type" оба ссылаются на одну концепцию.

## Экземпляры (instance)
В отличие от неоднозначности терминов "класс" и "тип", экземпляр - это синоним термина "объект".
Еще раз: объекты - это экземпляры типов. Так, "42 это экземпляр типа int" равносильно "42 - объект int". 
Термин "экземпляр" используется во встроенной функции `isinstance()`.

В Python все - объект, поэтому любой класс - это тоже объект, и его тип "type". 
Повторим еще раз: все пользовательские типы являются экземплярами класса type. 

Введем новый термин: Метакласс - это специальный класс, конструктор которого возвращает класс. То есть, связь метакласс->класс аналогична связи класс->объект. Тот факт, что классы являются экземплярами класса "type", позволяет нам создавать свои метаклассы (классы, которые наследуются от класса "type" и конструктор которых возвращает класс). Зачем? Отвечает гуру питона Тим Питерс

```
Метаклассы это глубокая магия, о которой 99% пользователей даже не нужно задумываться. Если вы думаете, нужно ли вам их использовать — вам не нужно (люди, которым они реально нужны, точно знают, зачем они им, и не нуждаются в объяснениях, почему).
```

Как правило, метаклассы используют при написании фреймворков уровня Django, они позволяют вынести часть внутренней магии выше пользовательского кода, чтобы "пользователь" не вдавался в подробности реализации.

## Итог
Напрашивается наивный вопрос: так что же главнее - type или object?
```python
>>> type.__bases__
(<class 'object'>,)
>>> object.__bases__
()
```
type наследуется от object, но при этом же:
```python
>>> type(object)
<class 'type'>
```
object имеет тип type. По сути, object - корень иерархии объектов, а type - корень иерархии типов. Каждый тип это объект, а у каждого объекта есть тип, этим и вызвана такая двойственность их определений. Среди них нет первоисточника, это примерно как пытаться сравнивать теплое с мягким.

## Примечание
Следует отличать встроенную функцию `isinstance()` и оператор `is`:

`isinstance(object, classinfo)` возвращает True, если аргумент `object` является экземпляром аргумента `classinfo`, либо экземпляром класса, унаследованного от `classinfo`.

Оператор `is`, в свою очередь, возвращает True, если две переменные ссылаются на один объект, т.е. сверяет идентификаторы объектов.

## Динамическое создание классиов через type()
Вместо вызова с одиним аргументом, `type()` можно вызвать с тремя:

`type(classname, superclasses, attributes_dict)`

Если `type` вызван с тремя аргументами, он вернет новый объект `type`. Это позволяет динамически формировать классы:

*"classname" - строка, которая определяет имя класса и становится его атрибутом `__name__`;
"superclasses" - это кортеж родительских классов, становится атрибутом `__bases__`;
"attributes_dict" - это словарь, представляющий пространство имен нашего класса. Он содержит определенние тела класса и становится его атрибутом `__dict__`. Атрибутами класса могут быть любые объекты:*

```python
>>> m = type("mytype", (int,), {"test": "field", "greet": lambda: print("hello word")})
>>> m.test
'field'
>>> m.greet()
hello word
```
